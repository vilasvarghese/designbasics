Software Architecture Course Outline
Duration: 3 Days

Overview of Software Architecture
--------------------------------------------------------------------------------------
	Software architecture 
		high-level structure and organization of a software system. 
		blueprint for 
			designing, 
			implementing, and 
			managing 
				the software application. 
	key aspects of software architecture:
	====================================
		Introduction to Software Architecture:
			Definition and importance of software architecture
			Role of software architecture in 
				design and development process
			Relationship between software architecture and system requirements

		Architectural Styles and Patterns:
			Overview of different architectural styles (e.g., layered, client-server, microservices)
			Explanation of common architectural patterns (e.g., MVC, MVP, MVVM)
			Selection of appropriate architectural styles for specific project needs

		Key Architectural Components:
			Presentation layer: User interface and interaction components
			Business logic layer: Core functionality and processing components
			Data access layer: Database and data management components
			Integration layer: Communication and interaction with external systems

		System Decomposition:
			Breaking down the system into modules or components
			Identifying responsibilities and interactions between components
			Designing interfaces and APIs for component communication

		Design Principles and Quality Attributes:
			SOLID principles: 
				Single Responsibility, 
				Open-Closed, 
				Liskov Substitution, 
				Interface Segregation, 
				Dependency Inversion
			Key quality attributes 
				(e.g., 
					scalability, 
					performance, 
					reliability, 
					maintainability)
			Design trade-offs and balancing conflicting quality attributes

		Architectural Views and Documentation:
			Logical view: High-level structure and organization of components
			Deployment view: Physical deployment and distribution of components
			Process view: Runtime behavior and interaction between components
			Documentation techniques and tools for capturing and communicating architecture

		Architectural Decision Making:
			Identify and analyze architectural drivers and constraints
			Evaluate design alternatives and make informed decisions
			Techniques for validating and verifying architectural choices

		Evolution and Change Management:
			Managing architectural changes and versioning
			Techniques to evolve and maintain architecture over time
			Impact analysis and risk management during architectural changes

		Integration and Interoperability:
			Integration strategies and patterns 
				(e.g., 
					message queues, 
					API gateways)
			Interoperability with external systems and services
			Managing dependencies and versioning in a distributed architecture

		Architectural Considerations for Non-functional Requirements:
			Security and privacy considerations
			Performance optimization and scalability techniques
			Fault tolerance and resilience mechanisms
			Usability and accessibility considerations

		Emerging Trends and Technologies:
			Cloud computing and serverless architectures
			Containerization and microservices
			Event-driven and reactive architectures
			Machine learning and AI integration in software architecture
--------------------------------------------------------------------------------------
	• Defining Software Architecture
--------------------------------------------------------------------------------------
		Software architecture
			process of designing and organizing the 
				structure
				components, and 
				behavior 
					of a software system. 
			It encompasses the fundamental decisions and principles 
				that guide the system's 
					construction, 
					ensure that it meets its functional and non-functional requirements 
						while promoting qualities like 
							scalability, 
							maintainability, and 
							reusability.

		Software architecture 
			make strategic design choices 
				to define the overall 
					structure and organization of the software system. 
			determine the 
				relationships, 
				interactions, and 
				dependencies 
					between various 
						components, 
						modules, and 
						subsystems of the system. 
			The architecture acts as a blueprint for development, providing a high-level view of the system's key elements and their interconnections.

		A well-designed software architecture should provide:

			Modularity and Component Reusability: 
				The architecture provide  
					separation of concerns
						allow components to be 
							developed, 
							tested, and 
							reused independently. 
					Enhances maintainability and 
					Reduces development time.

			Scalability and Performance: 
				consider 
					architectural patterns and techniques
					architecture can support 
						scalability 
							handle increased loads and 
						performance optimization 
							meet the system's performance requirements.

			Flexibility and Adaptability: 
				easily incorporate 
					new features, 
					enhancements, and 
					technology changes, 
				enable the system to adapt to evolving business needs.

			Maintainability and Testability: 
				The architecture facilitates 
					code organization, 
				Make it easier to 
					maintain, 
					debug, and 
					test the software system. 
				promote best practices 
				modular design principles
				improve overall quality.

			Collaboration and Communication: 
				Architecture should 
					Define common language for stakeholders
					allow effective communication among 
						developers, 
						designers, 
						project managers, and 
						other team members. 
					align everyone's understanding of 
						system's structure and behavior
						how to build the same.

		Software architecture
			documented through 
				architectural diagrams
				specifications, and 
				design documents
			serve as a reference for development teams. 
			It is an iterative and evolving process, requiring continuous refinement and adaptation as the system evolves and new requirements emerge.



--------------------------------------------------------------------------------------
	• What’s Architecture and what’s not
--------------------------------------------------------------------------------------
		Architecture, in the context of software development, refers to the high-level design and structure of a software system. It encompasses the key decisions and principles that guide the system's construction, including the organization of components, the relationships between them, and the overall behavior of the system. Architecture defines the foundation upon which the software is built and provides a roadmap for its development and evolution.

		On the other hand, there are certain aspects that are not considered part of software architecture:

			Implementation Details: Software architecture focuses on the overall design and structure of the system, not the specific details of implementation. Implementation details, such as algorithms, data structures, and specific coding techniques, are part of the implementation process and are not typically considered architecture.

			Low-Level Design Choices: While architecture deals with high-level decisions and principles, low-level design choices, such as the selection of programming languages, frameworks, and libraries, are typically not part of architecture. These choices are made during the implementation phase and are based on the architectural decisions already made.

			Individual Code Modules or Functions: Software architecture focuses on the system as a whole and its components rather than individual code modules or functions. While the architecture defines the relationships between components, the detailed design of each module or function is considered part of the implementation and coding phase.

			Business Logic or Domain-Specific Details: While the architecture may include an understanding of the system's functional requirements, it does not delve into the specifics of the business logic or domain-specific details. These details are typically addressed during the requirements analysis and modeling phase, prior to the architecture design.

			User Interface (UI) Design: While the architecture may define the overall structure and interaction between components, it does not typically address the detailed design of the user interface. UI design, including the visual appearance, layout, and user experience, is typically considered a separate design discipline.
--------------------------------------------------------------------------------------
	• Architecture Process
--------------------------------------------------------------------------------------
		Different names 
			architecture process
			software architecture design 
			software architecture development
			
				systematic approach to 
					designing the structure and organization of a software system. 
		Key steps of software architecture:

		1. Requirements Gathering and Analysis: 
			First understand and analyze 
				system's functional and non-functional requirements. 
				Identify stakeholders
				capturing their needs
				defining the system's goals and constraints.

		2. System Decomposition: 
			Break down the system into 
				components or modules
			identify 	
				major subsystems
				their responsibilities, and 
				interactions between them. 
			Various ways to do system decomposition 
				functional decomposition
				object-oriented analysis
				use case modeling etc.

		3. Architectural Styles and Patterns: 
			Based on the requirements 
				selecting suitable architectural styles and patterns 
			evaluate different options
				e.g. 
					layered architecture
					client-server architecture
					microservices 
					event-driven architecture
			select the most appropriate 
			aligns with the system's needs and goals.

		4. Designing System Components: 
			design individual 
				components or modules 
				
			define 
				responsibilities, 
				interfaces, and 
				dependencies 
					of each component. 
			e.g. Consider techniques to use 
				component-based design 
				object-oriented design .

		5. Defining Architectural Views: 
			Architectural views 
				provide different perspectives on the system
				cater to various stakeholders' needs. 
			Different views 	
				logical view
				deployment view
				process view
				development view
				
				They capture different aspects of the system's architecture. 
			
		6. Iterative Refinement and Evaluation: 
			architecture design process 
				generally iterative
					multiple rounds of refinement and evaluation. 
			
			review architecture with requirements
			identifying design issues or risks
			make necessary adjustments. 
			
			Evaluation techniques
				architectural reviews
				prototyping, or 
				simulation
					validate and refine the architecture.

		7. Documentation and Communication: 
			Proper documentation of the architecture 
				effective communication and 
				future reference. 
			create 
				architectural diagrams
				specifications, and 
				design documents 
			Document 
				key design decisions
				rationale, and 
				dependencies. 
			Single source of truth for 
				development teams
				stakeholders
				future maintenance efforts.

		8. Implementation and Validation: 
			Once the architecture is designed
				implementation phase begins
					developers develop.
			During implementation and testing 
				architecture is validated 
			
		architecture process 
			not a one-time activity 
				ongoing effort 
					throughout the software development lifecycle. 
		system evolves
			architecture are 
				revisited and 
				adapted 
					to accommodate 
						changing requirements or 
						new technological advancements. 
			So 
				maintain architecture 
				conducting regular architectural reviews 
--------------------------------------------------------------------------------------
	• Alternative Thoughts of Software Architecture
--------------------------------------------------------------------------------------
		Traditional software architecture process 
			systematic and structured approach
		Alternative to software architecture:
			Emergent Architecture: 
				gradually emerging architecture 
					through iterative and incremental development 
				No upfront detailed architecture design
				focus on delivering working software 
				architecture evolve 
					organically based on 
						emerging requirements and 
						feedback.

			Agile Architecture: 
				In line with agile software development methodologies
				promotes a flexible and adaptive architecture 
				can quickly respond to changing requirements and priorities. 
				continuous collaboration
				incremental architecture design
				frequent refactoring 
					maintain balance between 
						short-term development needs and 
						long-term architectural goals.

			Lightweight Architecture: 
				Emphasizes simplicity and minimalism in architecture design. 
				Discourage 
					over-engineering and 
					excessive complexity
					focusing on creating the simplest architecture 
				lean and agile architectural decisions 
					prioritize 
						ease of understanding
						maintenance, and 
						responsiveness.

			Domain-Driven Design (DDD): 
				Emphasizes 
					understanding and modeling the domain of the software system 
						as the primary driver of architecture design. 
				close collaboration between domain experts and developers
				architecture designed should align closely with the business domain's 
					concepts
					language
					behavior.

			Reactive Architecture: 
				Emphasizes 
					responsiveness
					resilience
					elasticity
					message-driven communication 
						in the design of distributed systems. 
				It focuses on handling and reacting to 
					large # of concurrent events
						provide scalability 
						fault-tolerance 
							through asynchronous
							event-driven architectures.

			Context-Driven Architecture: 
				architecture 
					should aling to specific context in which it operates. 
					understanding 
						unique characteristics
						constraints, and 
						requirements of the system's environment
							e.g. 
								organization
								technology stack
								user base, and 
								operational constraints.
--------------------------------------------------------------------------------------
	• Why Software Architecture Matters
--------------------------------------------------------------------------------------

	Software architecture matters because 
		provides a blueprint for the development of software systems. 
		Influences 
			system understanding
			scalability
			performance
			maintainability
			reliability
			adaptability, and 
			Other overall system quality. 
		By making informed architectural decisions, software teams can 
			deliver high-quality systems 
			that precisely meet stakeholders' needs
			are cost-effective
			can evolve with changing requirements and technological advancements.


	Software architecture matters because 
		Ensure common System Understanding: 
			Software architecture 
				high-level overview and representation of 
					system's structure
					components, and 
					interactions. 
			All stakeholders including 
				developers
				designers
				project managers, and 
				clients
					to understand and communicate 
						system's design
						functionality, and 
						constraints. 
			A well-defined architecture 
				is a common language for 
					effective collaboration and 
					decision-making.

		System Scalability and Performance: 
			Architecture defines how to scale.
				Uses 
					architecture types
					design patterns
					distribution strategies
					and scalability techniques
					
		System Maintainability and Extensibility: 
			A well-designed architecture promotes 
				maintainability and extensibility. 
			Allows 
				modular development
					provides clear boundaries between components. 
			Adv. 
				Easier troubleshooting
				bug fixing
				easy to add new features or enhancements. 
			Changes in one component can be 
				localized
				minimize the impact on the overall system.

		System Reliability and Resilience: 
			Architecture influences the system's 
				reliability and 
				resilience 
					by incorporating 
						fault-tolerant 
						redundancy
						error handling strategies. 
			
		Other System Quality Attributes: 
			Architecture design decisions impact 
				quality attributes like 
					security
					usability
					accessibility, and 
					maintainability. 
					
				Most used quality attributes 
					#1) Reliability
					#2) Maintainability
					#3) Usability
					#4) Portability
					#5) Correctness
					#6) Efficiency
					#7) Security
					#8) Testability
					#9) Flexibility (Modifiability)
					#10) Scalability
					#11) Compatibility
					#12) Supportability
					#13) Reusability
					#14) Interoperability
					

		System Evolution and Adaptability: 
			Software systems evolve over time due to 
				changing requirements
				technology advancements
				market demands etc. 
			Architecture should provides 
				foundation for 
					future changes and adaptations. 
					easier integration of new technologies
					incorporate new functionalities
					migrate to different platforms or environments.

		System Cost and Time-to-Market: 
			Architecture influences 
				overall cost and 
				time required for system development. 
			Architecture should reduce 
				rework
			Enhances 
				code reusability and 
				efficient development practices. 
				parallel development and 
				integration of third-party components or services
				
				Result 
					faster development cycles 
					reduced time-to-market
					reduced cost.

		System Stability and Robustness: 
			Architecture should ensure 
				system stability and 
				robustness 
					by considering 
						dependencies
						interactions, and 
						performance implications. 
			Use proper 
				load balancing, 
				resource management, and 
				error handling, 
					minimizing the risk of system failures or performance bottlenecks.

--------------------------------------------------------------------------------------
	• Creating an Architecture
--------------------------------------------------------------------------------------
		Creating an architecture 
			systematic approach to several key steps. 
			Here's a general outline of the process:

		1. Understand Requirements: 
			Start by requirement gathering 
				understand 
					functional and non-functional requirements 
			Engage with stakeholders
				end-users
				clients, and 
				domain experts
					identify their 
						needs
						goals, and 
						constraints. 
				Document the requirements 
				ensure clarity before proceeding further.

		2. Identify Key Scenarios: 
			Identify and prioritize 
				functional and non functional 
					use cases 
			Define core functionalities and interactions 
				that architecture must address. 
			Identify 
				major components
				dependencies, and 
				interactions required.

		3. Define Architectural Goals and Constraints: 
			Define 
				architectural goals and 
				constraints that will guide the design process. Consider factors such as performance requirements, scalability, security, maintainability, and integration with existing systems or platforms. Identify any external standards or regulations that need to be followed.
				
			e.g. 
				Architectural Goals:
					Scalability: 
					Performance: 
					Reliability: 
					Security: 
					Maintainability: 
					Flexibility: 
					Interoperability: 
					Usability: 
				Architectural Constraints:
					Technology Stack: 
					Budget and Cost: 
						Architecture should be designed within a 
							specified budget and 
							cost constraints, 
							considering factors such as 
								hardware, 
								software licenses, and 
								infrastructure.
					Time-to-Market: 
					Regulatory Compliance: 
					Legacy System Integration: 
					Performance Constraints: The architecture must meet 
						specific performance requirements
								response time
								throughput, or 
								resource utilization.
					Resource Constraints: 
						consider limitations on 
							hardware resources
							network bandwidth, or 
							storage capacity.
					Accessibility: 	

		4. Select Architectural Patterns and Styles: 
			Analyse  
				requirements
				scenarios, and 
				goals, 
			select suitable 
				architectural patterns and styles. 
			These patterns 
				provide proven solutions to 
				common architectural problems. 
			e.g. 
				layered architecture
				client-server architecture
				microservices
				event-driven architecture
				hexagonal architecture. 
			Choose the patterns that best align with the system's needs and constraints.

		5. Decompose the System: 
			Decompose system into 
				logical components or 
				modules based 
					according to the architectural patterns. 
			Identify 
				major subsystems
					responsibilities
					relationships 
					dependencies 
			Options 
				functional decomposition 
				object-oriented 
					analysis to refine the decomposition.

		6. Define Component Interfaces: 
			Define 
				interfaces between components
				inputs
				outputs
				communication mechanisms. 
			define 
				responsibilities and 
				contracts 
					of each component
			ensure 
				cohesion and 
					degree of relatedness
					how closely the elements within a module or component are related 
					how well they work together to achieve a common purpose. 
					High cohesion 
						elements are strongly related and focused
					low cohesion 
						indicates that the elements are loosely related and may have different purposes.
				loosely coupling. 
				Consider factors like 
					data exchange formats
					communication protocols
					error handling.

		7. Address Cross-Cutting Concerns: 
			Identify and address cross-cutting concerns 
				e.g. 
					security
					logging
					caching
					authentication, and 
					error handling
					event handling 
					monitoring 
					
		8. Design for Quality Attributes: 
			Consider the desired quality attributes of the system
				e.g. 
					performance
					scalability
					reliability, and 
					maintainability. 
			
		9. Iterate and Refine: 
			Architecting
				an iterative process. 
				Continuously refine and validate the architecture through 
					reviews
					discussions, and 
					feedback 
						from stakeholders. 
				
		10. Document the Architecture: 
			clear and concise manner. 
			Create architectural diagrams like 
				component diagrams
				deployment diagrams, or 
				sequence diagrams
					to illustrate 
						structure and behavior of the system. 
			document rationale behind 
				design decisions
				interfaces, and 
				dependencies. 
			
		11. Validate the Architecture: 
			Validate the architecture through 
				prototyping
				proof-of-concepts, or 
				simulations. 
			Evaluate its 
				feasibility
				performance, and 
				compliance with requirements. 
			Address any identified risks or issues and make necessary refinements.

--------------------------------------------------------------------------------------
	• Patterns and Architecture
--------------------------------------------------------------------------------------
		Patterns and architectures
			Provide 
				guidelines
				best practices, and 
				reusable solutions 
					for solving common problems and structuring software systems. 
		
		Software design patterns (Patterns):
			 proven solutions 
				to recurring problems 
			best practices 
			template for solving specific design problems. 
			Categorized 
				creational patterns 
					(e.g., Factory Method, Singleton)
				structural patterns 
					(e.g., Adapter, Decorator), 
				behavioral patterns 
					(e.g., Observer, Strategy). 
			
		Architectures:
			Software architecture 
				high-level structure and organization of a software system. 
			defines 
				how different components and modules of the system interact 
				how they fulfill the system's functional and non-functional requirements. 
				define the blueprint for designing 
					scalable
					maintainable
					robust systems. 
			Examples 
				layered architecture
				client-server architecture
				microservices architecture
				event-driven architecture
		
		Advantages of Patterns and Architectures:

			Reusability: 
				Provide reusable solutions 
					can be applied to different projects and contexts.
			Maintainability: 
				Patterns and architectures promote modular and organized code structures, making it easier to maintain and enhance the software system.
			Scalability: 
				Well-designed architectures allow for the system to scale horizontally or vertically to handle increased workloads and user demands.
			Flexibility: 
				Patterns and architectures enable flexibility in adapting to changing requirements and incorporating new functionalities.
			Testability: 
				Modular and decoupled designs facilitated by patterns and architectures improve the testability of the system.
			Collaboration: 
				Patterns and architectures provide a common language and understanding among developers, facilitating communication and collaboration within development teams.
			Software developers and architects 
				should be familiar with 
					different patterns and 
					architectures 
						to effectively design and build software systems that are efficient, maintainable, and scalable. Applying patterns and selecting appropriate architectures can greatly influence the success of a software project.






--------------------------------------------------------------------------------------
	• Architecture Evolution and Migration
--------------------------------------------------------------------------------------
		Architecture evolve and migrate 
			process of evolving an existing software system's architecture 
			or 
			migrating it to a new architecture 
				to meet changing business needs, improve performance, enhance maintainability, or adopt new technologies. Here's an overview of architecture evolution and migration:

		Reasons for Architecture Evolution and Migration:
			1. Changing business requirements: 
			2. Performance optimization: 
			3. Technology advancements: 
			4. Legacy system modernization: 
			
		Assessment and Planning:
			Evaluate the current architecture: 
				existing architecture
				strengths
				weaknesses, and 
				alignment with business goals.
			Identify pain points and goals: 
				Determine where 
					architecture needs improvement or 
					desired outcomes of the migration.
			Define target architecture: 
				Define the ideal architecture.
		Migration Strategies:
			Big-bang migration: 
				A complete and immediate transition 
					to the new architecture
				stop the system and 
				migrate all components at once.
			Incremental migration (Strangler pattern): 
				Gradual migration of the system
				components are migrated 	
					one at a time or 
					in stages
					
				smoother transition and 
				reduced risks.
			Hybrid approach: 
				Combine elements of both big-bang and incremental 
					e.g. 
						migrating some critical components first 
						while gradually transitioning the rest.
		Implementation:
			Redesigning components: 
				Modify existing components 
					according to new architecture
				ensure compatibility and proper integration with other components.
			Rewriting code: 
				complete rewrite if required.
			Data migration: 
				Migrating data from the old system to the new architecture.
		Testing and Validation:
			Comprehensive testing: 
				Functional and Non Functional testing.
			User acceptance testing: 
				
		Post-Migration:
			Monitoring and optimization: 
			Documentation and knowledge transfer: 
				
--------------------------------------------------------------------------------------
	• Features vs Capabilities
--------------------------------------------------------------------------------------
		Features and capabilities 
			terms used interchangeably 
			But slightly different interpretations:

		Features of Software Architecture:
			functional/non functional aspects
			
			Define 
				explicit capabilities that 
		Flexibility: 
			adapt to changing requirements
			allow for easy modifications or additions 
				without extensive rework.
		Performance: 
			meet or exceed 
				specified performance metrics
					e.g. 
						response times or 
						throughput.
		Capabilities of Software Architecture:
			Capabilities 
				overall capacities or competencies of the architecture 
					to fulfill various system requirements 
				They represent the holistic set of qualities that the architecture possesses.
				
			Examples of architecture capabilities may include:
				Interoperability: 
					Architecture's ability to interact and integrate 
						with other systems or components 
						using standard protocols or interfaces.
				Extensibility: 
					The capacity to accommodate new features or functionalities 
						without significant changes.
				Maintainability: 
					The ease with which the architecture can be 
						understood
						modified, and 
						repaired 
							to ensure long-term support and enhancements.
				Reliability: 
					The ability of the architecture 
						to consistently perform its intended functions 
						with minimal failures or errors.
				Testability: 
					ease with which the architecture can be tested 
						to ensure correct 
							behavior
							identify defects, and 
							validate system requirements.
			While features focus on the specific functionalities that the architecture provides, capabilities encompass a broader range of qualities and characteristics that define the architecture's overall competencies. Both features and capabilities are essential considerations when designing and evaluating software architectures, as they directly impact the system's performance, flexibility, and success in meeting its intended objectives.

--------------------------------------------------------------------------------------
	• Different types of Architecture
--------------------------------------------------------------------------------------
	There are various types of software architectures that can be used to design and structure software systems. Each type of architecture has its own characteristics, benefits, and considerations. Here are some commonly used types of software architectures:

------------------------
		Layered Architecture:
			Also called n-tier architecture.
			Divides the system into logical layers
				like 
					presentation layer
					business logic layer
					data layer.
			Each layer has a specific responsibility 
				communicates with adjacent layers through defined interfaces.
			Promotes 
				separation of concerns
				modularity, and 
				maintainability.

-------------------
|    Presentation   |
-------------------
|   User Interface  |
-------------------

-------------------
|     Application   |
-------------------
|   Business Logic  |
-------------------


--------------------------
|     Persistence Layer   |
--------------------------
|   	Caches  		  |
--------------------------


-------------------
|    Data Access    |
-------------------
|    Data Storage   |
-------------------

			Presentation Layer: 
				handles 
					user interface and 
					presentation logic. 
				capture user input
				displaying information to the user
				interacting with the underlying layers.

			Application Layer: 
				defines application logic 
					i.e. implementing the business rules and workflows
					orchestrates the flow of data and business operations. 
				manages interaction between the 
					presentation layer and 
					lower layers

			Data Access Layer: 
				responsible for interacting with the data storage systems
					like databases or external services. 
				logic to retrieve, store, and update data is managed here.

			Data Storage Layer: 
				actual data storage systems like 
					databases or file systems. 
				Handles 
					persistence and retrieval of data
						defined data models and schemas.


------------------------
		Client-Server Architecture:
			Divides the system into client-side and server-side components.
			Clients make requests to the server 
			for resources or services.
			Servers 
				handle requests
				process data, and 
				provide responses to clients.
			scalability
			centralized data management, and 
			distribution of processing load.
			
-------------------       -------------------
|      Client       |       |      Server       |
-------------------       -------------------
| User Interface    |       |    Application    |
|   Presentation    |       |     Business      |
|    Logic          |       |       Logic       |
-------------------       -------------------
|    Network        |       |    Database       |
|    Communication  |       |     Storage       |
-------------------       -------------------
			In a Client-Server architecture
			system 
				divided into two main components: 
					the client and 
					the server. 
			The client 
				responsible for 
					user interface and presentation logic
			server component 
				contains the application and business logic.

			The main elements in this architecture are:

			Client: 
				component 
				represents user-facing part of the system. 
				includes 
					user interface 
					presentation logic
						display information to the user
						capturing user input, and rendering the user experience.

			Server: 
				hosts the application and business logic. 
					receives requests from the client
					processes them
					performs the necessary computations, 
					responds back. 
				Can include multiple layers
					e..g 
						application logic layer 
						data storage layer.

			Network Communication: 
				The network communication layer 
				facilitates communication between 
					client and
					server. 
				

			Database Storage: 
				storage layer 
					responsible for persisting and managing the application's data

			The Client-Server architecture is commonly used in distributed systems, where the client and server components can be deployed on different machines or networked devices. The client sends requests to the server for processing, and the server responds with the required information or performs the requested actions.

			Please note that this is a simplified representation of the Client-Server architecture, and real-world systems can have more complex variations and additional layers based on specific requirements and design choices.


------------------------
		Microservices Architecture:
			Organizes the system into a collection of small, independent, and loosely coupled services.
			Each service represents a specific business capability and communicates through well-defined APIs.
			Promotes scalability, flexibility, and the ability to deploy and update services independently.
			Challenges include managing inter-service communication and ensuring data consistency.
			
			


------------------------
		Event-Driven Architecture:
			Focuses on the flow of events or messages between components.
			Components (publishers) 
				generate events 
				notify other components 
					(subscribers) asynchronously.
			Enables 
				loose coupling
				scalability
				flexibility in handling complex workflows and event-driven scenarios.

-------------------       -------------------       -------------------
|   Event Source   |       |     Event Broker |       |   Event Handler  |
-------------------       -------------------       -------------------
|    Producer      | ----> |    Event Queue   | ----> |     Consumer     |
|     Component    |       |   (Message Bus)  |       |    Component     |
-------------------       -------------------       -------------------
			In an Event-Driven Architecture
				components communicate with each other through events. 

				message driven 
				scalable 
				resilient
				responsive

			The flow of the Event-Driven Architecture is as follows:
				The event source 
					(producer) generates an event.
					event is published or sent to the event bus (event queue).
				event broker 
					receives the event and 
					distributes it to the appropriate event handler (consumer).
				The event handler 
					processes the event and 
					performs the necessary actions or computations.

			
			The main elements in this architecture are:

			Event Source: 
				generates events. 
				any entity or system that produces events
					such as user actions
					sensors
					external systems. 
					The event source acts as a producer of events.

			Event Bus: 
				event bus 
					communication channel for events. 
					acts as 
						message broker or message queue
						receiving events from the event sources 
						routing them to the appropriate event handlers. 
						It provides a centralized hub for event distribution.

			Event Handler: 
				consumer, processes and reacts to events. 
				listens for events on the event bus 
				performs specific actions or computations based on the received events. 
				
				https://softwaremill.com/kafka-visualisation/

				The Event-Driven Architecture enables loose coupling and scalability as components can react to events independently and in parallel. It supports a decoupled and asynchronous communication model, where components can respond to events as they occur, enabling real-time and reactive systems.

			Please note that this is a simplified representation of the Event-Driven Architecture, and real-world systems can have more complex variations and additional components based on specific requirements and design choices.
------------------------


		Service-Oriented Architecture (SOA):
			Organizes the system 
				as a set of services 
				loosely coupled and 
				independently deployable.
			Services 
				expose functionalities 
				through standardized interfaces 
					(e.g., web services, REST APIs).
			Promotes reusability
				interoperability
				agility in building and integrating systems.
			

-----------------------        -----------------------        -----------------------
|    Service Consumer  |        |      Service Bus     |        |    Service Provider  |
-----------------------        -----------------------        -----------------------
|                      | ---->  |                      | ---->  |                      |
|     Client Program   |        |    Service Registry  |        |   Service Component  |
|                      | <----  |                      | <----  |                      |
-----------------------        -----------------------        -----------------------
			In a Service-Oriented Architecture
				composed of 
					loosely coupled
					autonomous, and 
					reusable 
						services 
							communicate with each other to fulfill 
							specific functions or business processes.

			The flow of the Service-Oriented Architecture is as follows:
				Service consumer (client program) 
					sends a request 
						to the service bus.
				Service bus 
					routes the request to the appropriate service provider 
						based on the requested service.
				Service provider 
					receives the request
					processes it
					sends back the response.
				Service bus 
					forwards the response to the service consumer.
				The Service-Oriented Architecture promotes 
					loose coupling
					reusability, and 
					interoperability. 
				Services can be 
					developed, 
					deployed, and 
					updated 
						independently
					allow flexibility and scalability. 
					Enables systems to be composed of 
						modular, 
						self-contained 
							services 
						can be easily integrated and reused across different applications and platforms.


			The main elements in this architecture are:
				Service Consumer: 
					client program
					a web application, or any entity 
						that needs to consume services.
					requests services from service providers. 
				Service Bus: 
					acts as a communication infrastructure 
					facilitates the interaction between 
						service consumers and 
						service providers. 
					centralized hub for 
						service discovery
						routing, and 
						messaging. 
					can do 
						protocol transformation
						data transformation
						and security.
				Service Provider: 
					offers services to service consumers. 
					exposes well-defined interfaces or APIs 
						define capabilities and functionality of the services. 
					can be 
						individual components
						microservices, or 
						even external systems.
				Service Registry: 
					centralized repository 
					Helps service discovery
					Service consumer locate the services they need.
					keeps track of 
						available services and 
						their locations. 
					
				Please note that this is a simplified representation of the Service-Oriented Architecture, and real-world systems can have more complex variations, such as service choreography or orchestration, service governance, and service composition, based on specific requirements and design choices.






			
------------------------			
		Monolithic Architecture:
			traditional
			single-tier architecture 
				entire system is 
					developed and deployed as a single unit.
			Components are 
				tightly coupled
				(small) changes often require redeployment of the entire system.
			Simplicity and ease of development and deployment
			but lacks 
				scalability and 
				flexibility compared to more distributed architectures.
		
		
-----------------------
|    Monolithic App   |
-----------------------
|                     |
|   Application       |
|   Components        |
|   (Frontend,        |
|    Backend,         |
|    Database, etc.)  |
|                     |
-----------------------
			In a Monolithic Architecture
				entire application 
					developed as a 
						single
						self-contained unit. 
				components and functionality (of the application) 
					tightly coupled and 
					deployed together.

			The main elements in this architecture are:
				Monolithic App: The monolithic app represents the entire application as a single unit. It typically includes multiple components such as the frontend, backend, database, and any other necessary components.
				Application Components: These are the different functional components that make up the application. It can include user interfaces, business logic, data access layers, and other modules or services that are required for the application to function.

			The flow in Monolithic Architecture 
				tightly integrated
				components interact directly 
					with each other within the same application:

			User interacts with 
				frontend component of the application.
			The frontend component 
				handles the user input
				processes it
				communicates with the backend component.
			The backend component 
				performs business logic
				accesses the database if required
				generates a response.
				The response 
					sent back to the frontend component
					presents it to the user.
			In a Monolithic Architecture
				all components are 
					deployed and 
					scaled together 
						as a single unit. 
				simple development and deployment 
					only a single service 
					So no multi-service complexity 
				Tough to 	
					scale
					maintain, and 
					modularize
						when application grows larger and more complex.

			Please note that this is a simplified representation of the Monolithic Architecture, and real-world monolithic applications can have more components and layers based on specific requirements and design choices.
		
	
------------------------	
		Domain-Driven Design (DDD):
			Emphasis on the 
				business domain 
					models the software system around it.
			Defines 
				bounded contexts
				aggregates, and 
				entities that represent the core business concepts.
			Promotes a common language 
				between developers and domain experts
				Ensure a better alignment between business and software.
			
			

---------------------------------
|           User Interface       |
---------------------------------
|             |                 |
|    Views    |   Controllers   |
|             |                 |
---------------------------------
|          Domain Model          |
---------------------------------
|          Repositories          |
---------------------------------
|          Infrastructure       |
---------------------------------
		
	The key components in this architecture are:
		User Interface: 
			user-facing part of the application. 
			Includes 
				views
					present information to the users
				controllers
					handle user interactions and 
					delegate actions to the domain model.

		Domain Model: 
			Core of the application. 
			Encapsulates business logic and behaviors of the domain. 
			It consists of 
				entities, 
				value objects, 
				aggregates, and 
				domain services that collaborate to solve domain-specific problems.

		Repositories: 
			abstraction for 
				storing and 
				retrieving 
					domain objects. 
			bridge between 
				domain model 
				underlying data storage like 
					databases or 
					external services.

		Infrastructure: 
			technical components and services 
				support the application. 
			Includes 
				frameworks
				libraries
				external APIs, and 
				infrastructure-specific code. 
			handles technical concerns like 
				persistence
				messaging, and 
				external integrations.

		The flow within the Domain-Driven Design architecture typically follows the principles of a layered architecture:

		User Interface components 
			interact with 
				views and 
				controllers 
					to handle user interactions 
					display information to users.

		Controllers 
			receive user requests
			validate inputs, and 
			coordinate with the domain model 
			to perform actions or retrieve data.

		The Domain Model 
			contains 
				business logic and 
				rules. 
			It 
				receives requests from the controllers
				executes the necessary operations
				produces the desired outcomes.

		Repositories provide the necessary data access and persistence operations for the domain model. They communicate with the underlying data storage to fetch or store domain objects.

		The Infrastructure layer provides technical services and components that support the application's functionality. It interacts with external systems, manages data persistence, and handles other technical concerns.

		It's important to note that this diagram represents a simplified view of the Domain-Driven Design architecture, and real-world implementations can have more complex interactions and additional layers or components based on specific requirements and design choices.
